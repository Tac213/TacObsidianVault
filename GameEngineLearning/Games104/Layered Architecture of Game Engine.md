游戏引擎是一个分层的架构，不同的引擎会把自己的架构分成不同的层级，但通常都可以分成下面5层：

- Tool Layer: 工具层，即用于生产游戏引擎所需资源的各种编辑器
- Function Layer: 功能层，例如动画、游戏脚本、AI等功能
- Resource Layer: 资源层，负责处理大量的数据、文件，负责加载、管理资源
- Core Layer: 核心层，负责内存管理、容器分配、提供基础数学模块
- Platform Layer: 平台层，处理不同平台之间的差异

另外还有ThirdParty。

通常不同的引擎会在Function Layer细分。

## Tool Layer

Tool Layer是最顶层，允许他人以Level Editor地图/场景编辑器为中心，形成的一系列的编辑器。工具层是生产力的工具。

工具层的开发很灵活，引擎一般使用的是C++，需要追求最高的效率Runtime，而工具层则有很多种解决方案。

## Function Layer

游戏是通过不断地tick模拟出来地虚拟世界，tick又分为tickLogic和tickRender。通常先tickLogic，把虚拟世界中正在发生地事情通过逻辑模拟出来，然后tickRender，把事情地接过渲染出来。Function Layer就是负责tickLogic和tickRender。

现代计算机的架构是多核的，在多核的计算机架构中，最基本的可以把TickLogic和TickRender分到不同的线程中去。在现在的商业引擎中，会把一些特别容易并行化的计算，如物理、动画，它会把它Fork出来，分担到很多线程上。

未来，我们希望把所有的任务变成一个原子，叫做Job，无论你有多少个核，将Job扔进这些核中，吃满核，但是这种方法其实并不是那么简单，当写功能层的时候，其实很多计算，都是有依赖关系Dependence，举个例子，角色A挥舞武器，然后武器上发出特效，是应该先获取到武器目标的最终位置，才能知道特效的生成位置，其中存在着先后关系，多核并行架构，难在Dependence的管理上面。

## Resouce Layer

Resouce Layer的首先需要考虑把各种资源，比如模型、贴图、动画等资源，把原始资源文件中冗余的、引擎不需要的数据去掉，转换为引擎的高效数据，转换之后我们就称其为Assets 资产。

其次需要考虑将不同的资源关联到一起。比如某个角色包含了Mesh、贴图、动画，需要另一个Composite Asset将他们关联起来。在现代游戏引擎中，最重要的就是数据之间的关联，亦可以叫做Reference，如果打开任何一个现代游戏，打开游戏目录，如果是没有压包好的话，是有上百万文件，其中有贴图、声音、动作等等，他们就像无数的网关联在一起。这其中有一个概念叫做：GUID 唯一识别号，给每个资产设定一个唯一识别号。

资源层，在游戏中，最核心的是管理所有我们做的这些资产的生命周期，所以资源层是游戏引擎非常核心的一个层次，它管理好整个游戏引擎跑起来的资源池的分配，是管理好每个资源在Run Time的生命周期。

## Core Layer

核心层中最容易获得大家关注的是数学库，游戏引擎中需要做大量的矩阵和向量的运算，CPU厂商提出了SIMD(Single Instruction Multiple Data)的概念，即一个LU，将四个运算全部做掉，这个也是引擎的数学库中，广泛使用的一个技术。

核心层不止于数学，核心层是为了上层逻辑提供了所有的基础服务，这其中很重要的一个就是数据结构。C++提供的标准容器，大量进行创建和删除，在内存中会形成大量的空洞，而且内存的使用不受到控制，而且这些内存会分的非常的开，游戏就会变得很慢，所以在核心层，我们需要做一套我们自己的数据结构，让它几乎没有内存碎片，保证访问效率非常的高，所以这也是核心层中最重要的一个功能：内存管理。

## Platform Layer

不同的平台可能文件路径不一样、图形学API不一样，需要又Platform Layer把这些差别全部抹平。比如现代游戏引擎中有一个非常重要的一层：RHI（Render Hareware Interface）它重新定义了一层Graphics的API，然后把各个图形学API的区别封装好。
